module Google
  module Protobuf
    class RepeatedField
      include Enumerable[untyped]

      extend Forwardable

      public

      def &: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def *: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def +: (untyped) -> untyped

      def -: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def <<: (untyped) -> untyped

      def <=>: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def ==: (untyped) -> untyped

      def []: (*untyped) -> untyped

      def []=: (untyped, untyped) -> untyped

      def assoc: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def at: (*untyped) -> untyped

      def bsearch: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def bsearch_index: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def clear: () -> untyped

      def clone: () -> untyped

      def collect!: (*untyped args) { (*untyped) -> untyped } -> untyped

      def combination: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def compact: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def compact!: (*untyped args) { (*untyped) -> untyped } -> untyped

      def concat: (untyped) -> untyped

      def count: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def cycle: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def delete: (*untyped args) { (*untyped) -> untyped } -> untyped

      def delete_at: (*untyped args) { (*untyped) -> untyped } -> untyped

      def delete_if: (*untyped args) { (*untyped) -> untyped } -> untyped

      def dig: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def drop: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def drop_while: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def dup: () -> untyped

      def each: () { (untyped arg0) -> void } -> void

      alias each_index each_with_index

      def empty?: () -> untyped

      def eql?: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def fetch: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def fill: (*untyped args) { (*untyped) -> untyped } -> untyped

      def find_index: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def first: (?untyped n) -> untyped

      def flatten: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def flatten!: (*untyped args) { (*untyped) -> untyped } -> untyped

      def freeze: () -> untyped

      def hash: () -> untyped

      def include?: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def index: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def insert: (*untyped args) { (*untyped) -> untyped } -> untyped

      def inspect: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def join: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      alias keep_if select!

      def last: (?untyped n) -> untyped

      def length: () -> untyped

      alias map collect

      alias map! collect!

      def pack: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def permutation: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def pop: (?untyped n) -> untyped

      def pretty_print: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def pretty_print_cycle: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def product: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def push: (*untyped) -> untyped

      def rassoc: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      alias reject! delete_if

      def repeated_combination: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def repeated_permutation: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def replace: (untyped) -> untyped

      def reverse: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def reverse!: (*untyped args) { (*untyped) -> untyped } -> untyped

      def rindex: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def rotate: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def rotate!: (*untyped args) { (*untyped) -> untyped } -> untyped

      def sample: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def select!: (*untyped args) { (*untyped) -> untyped } -> untyped

      def shelljoin: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def shift: (*untyped args) { (*untyped) -> untyped } -> untyped

      def shuffle: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def shuffle!: (*untyped args) { (*untyped) -> untyped } -> untyped

      def size: () -> untyped

      alias slice []

      def slice!: (*untyped args) { (*untyped) -> untyped } -> untyped

      def sort!: (*untyped args) { (*untyped) -> untyped } -> untyped

      def sort_by!: (*untyped args) { (*untyped) -> untyped } -> untyped

      def to_ary: () -> untyped

      def to_s: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def transpose: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def uniq: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      def uniq!: (*untyped args) { (*untyped) -> untyped } -> untyped

      def unshift: (*untyped args) { (*untyped) -> untyped } -> untyped

      alias values_at select

      def |: (*untyped args, **untyped) { (*untyped) -> untyped } -> untyped

      private

      def initialize: (Symbol, singleton(AbstractMessage)) -> void

      def pop_one: () -> untyped
    end
  end
end
